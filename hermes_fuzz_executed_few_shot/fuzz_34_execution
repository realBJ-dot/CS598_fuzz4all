'use strict';


class Foo {
  constructor(x) {
    console.log('FOO', x);
  } 

  foo() {
    if (this.x >= 4) {
      for (let i = 0; i < 3; i++) {
        console.log(`FOO`, this.x);
      }
    }
    console.log(`IF`, ifStatement(this.x > 4));
    console.log(`FOR`, forLoop(4));
  }

  async bar() {
    if (this.x >= 4) {
      for (let i = 0; i < 3; i++) {
        console.log(`BAR`, this.x);
      }
    }
    console.log(`IF`, ifStatement(this.x > 4));
    console.log(`FOR`, forLoop(4));
  }

  baz() {
    var self = this;
    self.foo();
    self.bar();
  }
}

foo() {}
bar();

function foo() {}
if (false) {
  for (let i = 0; i < 3; i++) {
    console.log('BAR', this.x);
  }
}

 

Currently, Hermes is working on supporting Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Future plans include support for Block scoped variables, Classes and method definitions, Expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes does not support Local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.

Execution Output ------------------:
test.js:36:7: error: ';' expected
foo() {}
      ^
