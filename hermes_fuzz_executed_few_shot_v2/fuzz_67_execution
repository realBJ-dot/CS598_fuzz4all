'use strict';

for (let i = 0; i < 2; i++) {
    let x = [0];
    x.length = 1;
    let f = function () { return x; };
    let _a;
    if (_some(x, f))
        break;
}

```
We strongly encourage you to try Hermes. You can build the project and test it yourself using this guide https: 

If you're familiar with RN and JavaScript, you can run Hermes on iOS at http://localhost:8081/index.js.

Please keep in mind that if you decide to switch between Hermes and non-hermes in production (testing on mobile), it will be hard to be sure that Hermes will handle all the cases of native code and native APIs. You can test on iOS Simulator and Android Emulator first to find out if all the cases of native code/APIs work.

## Performance

Hermes is built using in-memory bytecode written in Javascript. In-memory bytecode is compiled to run JavaScript code to native code first, then it runs the same non-native JavaScript code in the device's memory and return the native code's result to the runtime. In addition, Hermes generates high-performance bytecode for native code and runs it in JIT mode.

Hermes's jit engine is in native-to-Native mode. JIT engine generates a set of bytecode for every native JS code, with corresponding interpreter interprets them by interpreter and generates the native code for them by JIT engine.

For example, if you have `function foo(a, b) { return a - b; }` in non-hermes code, the native code for it is just like `foo = function __nativefoo(a, b) { return a - b; }`. In order to make JIT engine recognize the native code and interpret it, the runtime does the following steps:
1. Invokes `foo.attach` function in `foo.js`
2. Parses and collects native code from `foo` function
3. Invokes `foo.init` function on the native code, runs it, and returns the result.

The first step is the same in Hermes when you build your app: build a native code + JS files to `hermes-native/` directories. The native code's file names are the same as JS file names. The interpreter runs each native code in JIT mode to make sure that the native code's features and performance is supported in JIT mode.

For example, for JS library:
```javascript

Execution Output ------------------:
test.js:25:27: error: ';' expected
For example, if you have `function foo(a, b) { return a - b; }` in non-hermes code, the native code for it is just like `foo = function __nativefoo(a, b) { return a - b; }`. In order to make JIT engine recognize the native code and interpret it, the runtime does the following steps:
                          ^
