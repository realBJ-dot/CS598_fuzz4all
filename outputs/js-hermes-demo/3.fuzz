const fs = require('fs');




interface FileSystem {
  readDirectory(path: string, callback: (err: Error | null, results: string[]) => void): void;
}
const fsImpl = {
  readDirectory: (path: string, callback) => callback(null, ['a', 'b', 'c']),
  writeFile: (path: string, contents: string, callback) => callback(null, null)
}

```

Apart, Hermes currently is not supporting `module.exports`, `import/export`, `export default` and ES9 syntax, `async/await` keywords, and using classes with static methods.

*Note: Hermes uses ES6 code transformation and the generated bytecode and should be considered a beta release.*

## Compatibility

![hermes-browser-test-framework](docs/hermes-browser-test-framework/images/hermes-browser-test-framework.png)
 
<commit_msg>[android-docs] add android 11, iOS 13, react native 0.63 (android) support (#3869) (#3977)<commit_after>---
id: howherestest
title: How to create an internal test framework for Hermes
permalink: docs/howherestest.html
next: howheresruntime
---

Hermes is the core compiler of Hermes. In the beginning, we designed an internal test framework to emulate the execution engine capabilities of the web browser.

This section will detail how to create your own internal test framework and use it to create an easy-to-use debugger for Hermes.

## The internal test framework

The internal test framework is written in TypeScript and contains a handful of types and functions to help build upon.
```
 
export * from './test-runner-api';

 
export {
  startTestSuite,
  beforeEach,
  afterEach,
  describe,
  beforeAll,
  afterAll,
  xdescribe,
  it,
  test,
  xit,
  xdescribe
} from './test-runner-types';

 
export {
  TestConfig,
  TestRunner,
  BeforeEachCallbackType,
  BehCallbackContextType,
  BehCallbackType,
  AfterEachCallbackType,
  RunContextType,
  TestResultType,
  TestHookType,
  BeforeAllCallbackContextType,
  AfterAllCallbackContextType,
  DescribeHookContextType,
  ItHookContextType,
  CallContextType,
 