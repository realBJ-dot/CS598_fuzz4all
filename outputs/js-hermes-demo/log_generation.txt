[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const path = require('path');

const {
  createHermesRuntime,
  runJS,
  createEvalAndPrintHelpers,
  createStringifier,
} = await createHermesRuntime({
  shouldIgnorePromiseError: true,
});

 
   
     

const runEval = createEvalAndPrintHelpers(createHermesRuntime(), eval, runJS);

function findRoot(currentPath) {
  const isModule = /\.esm?\.js$/.test(currentPath);
  const isPackage = path.basename(currentPath).includes('/package.json');
  const isMain = isModule || isPackage;
  return isMain || isModule? '' : path.dirname(currentPath);
}

const files = ['./test/es6tests', './test/arraytests/es6array', './test/es6tests/es6tests', './test/es6tests/es6tests-05.js'];

for (const file of files) {
  const content = fs.readFileSync(path.resolve(__dirname, file), 'utf8');
  const out = runEval('var content =\n'+content);
  out.toFile('./test/es6output/' + path.basename(file).split('.js')[0] + '.json');
}

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const path = require('path');
const { evaluate, compile} = require('hermes-engine')  
const { withTimeout} = require('promisify-node');
const { promises:fsPromises} = require('fs');

const fileName = path.resolve(__dirname, 'hello-world.js');
async function main(){
  const code = await fsPromises.readFile(fileName, 'utf-8');
  
   
   
  
   
   
   
  let buffer = await evaluate(code);
  
   
   
  [buffer] = await toArrayBuffer(buffer);
    
  try{
     
    const func = await compile(buffer, { allowDynamicImport: false, mode:"text" });
    
    const r = await func();  
    
    console.log(r);
    
  }catch(e){
    console.log(e);
  }
}

main();
```
In the future, Hermes may also target a more strict subset of CommonJS.


[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const path = require('path');
const http = require('http');
const http1 = http.Server(function (req, res) {
  res.end('Hello, React Native!');
});
http1.listen(8081);


[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');




interface FileSystem {
  readDirectory(path: string, callback: (err: Error | null, results: string[]) => void): void;
}
const fsImpl = {
  readDirectory: (path: string, callback) => callback(null, ['a', 'b', 'c']),
  writeFile: (path: string, contents: string, callback) => callback(null, null)
}

```

Apart, Hermes currently is not supporting `module.exports`, `import/export`, `export default` and ES9 syntax, `async/await` keywords, and using classes with static methods.

*Note: Hermes uses ES6 code transformation and the generated bytecode and should be considered a beta release.*

## Compatibility

![hermes-browser-test-framework](docs/hermes-browser-test-framework/images/hermes-browser-test-framework.png)
 
<commit_msg>[android-docs] add android 11, iOS 13, react native 0.63 (android) support (#3869) (#3977)<commit_after>---
id: howherestest
title: How to create an internal test framework for Hermes
permalink: docs/howherestest.html
next: howheresruntime
---

Hermes is the core compiler of Hermes. In the beginning, we designed an internal test framework to emulate the execution engine capabilities of the web browser.

This section will detail how to create your own internal test framework and use it to create an easy-to-use debugger for Hermes.

## The internal test framework

The internal test framework is written in TypeScript and contains a handful of types and functions to help build upon.
```
 
export * from './test-runner-api';

 
export {
  startTestSuite,
  beforeEach,
  afterEach,
  describe,
  beforeAll,
  afterAll,
  xdescribe,
  it,
  test,
  xit,
  xdescribe
} from './test-runner-types';

 
export {
  TestConfig,
  TestRunner,
  BeforeEachCallbackType,
  BehCallbackContextType,
  BehCallbackType,
  AfterEachCallbackType,
  RunContextType,
  TestResultType,
  TestHookType,
  BeforeAllCallbackContextType,
  AfterAllCallbackContextType,
  DescribeHookContextType,
  ItHookContextType,
  CallContextType,
 
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

try {
  fs.open('hermes-broken.log', 'wr');
  throw Error('test');
} catch(e) {
  if ((e instanceof Error && JSON.stringify(e) === JSON.stringify(Error('test'))))
    console.log('Error:'+ e.message);
  else 
    throw e;
}

[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');


function f(x) {
  return x * x;
}

console.log(f(3));



[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

function callMe(functionToCall) {
    return Promise.resolve().then(() => {
        return Promise.resolve()  
      .then(() => {
            return Promise.resolve(functionToCall);
        })
      .then(() => {
            return Promise.resolve();
        })
      .then(() => {
            return Promise.resolve()  
        });
    });
}
const program = `
function foo() {
    this.m();
}
var r = foo();
var l = [new Promise(r => r())];
var t = new Promise((r, err) => {
    r();
});
function bar(r = new Promise((r) => r())) {
    return r();
}
var p = Promise.race([1, 2, 3]);
var s = "hello";
const v = "world";
function x(n) {
    return new Promise((r) => {
        r(n? 1 : 0);
    });
}
var b = x(true);
const w = x(false);
const d = typeof r.then? "resolve" : "reject";
function y() {
    return new Promise((r) => {
        r(123);
    });
}
y();
y().then((v) => {
    return v;
}).then((v) => {
    return v;
});
x(true)
  .then((v) => { return v + 5; })
  .then((n) => { return Promise.resolve(n); })
  .then((v) => { return Promise.resolve(v); });
    r = x(false);
const z = "123";
console.log('string', s, typeof s,'string', typeof s, 'number', s);
console.log('array', l[0].then((v) => { return v }), ['array', l[0].then((v) => { return v })]);
console.log('object', t.then((v) => { return v }), [{object: 'Promise.prototype'}, {object: 'Promise', value: t}]);
console.log('Promise', p.then((v) => { return v }), ['Promise', {array: [{object: 'Promise', value: p}], length: 3}]);
let p = {promise: new Promise(r => r())}, q = {promise: {value: "value"}};
p.promise.constructor = Array;
(q.promise).constructor = Number
return Promise.all([p.promise.then(v => v), q.promise.then(v => v)]);
`;
async function main() {
     
    let result = RN.FS.readFile('./src/rn-app/index.js', RN.FS.EncodingType.UTF8);
     
    let program = result.
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const p1 = new Promise(resolve => {
  fs.exists('blah.js', resolve);
});


```

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

async function read(filename) {
   
  const promise1 = fs.readFile(filename);
  const promise2 = fs.readFile(filename);
  await Promise.all([promise1, promise2]);
  return promise1.result;
}
async function main() {
  fs.readFile('hello.txt').then(value => {
    console.log(value.length);
  });
  const str = await read('hello.txt');
  
  const value2 = readSync('hello.txt');
  console.log(value2.length);
}
main();
 


[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const { runInHermes } = require('hermes-engine');

runInHermes(js =>
{
    const { callFunction, argumentCountMismatchError } = js;

    callFunction(js, Array.isArray.bind(''));  
    callFunction(js, Array.isArray.bind(13));  
    callFunction(js, Array.isArray.bind(false));  
    callFunction(js, Array.isArray.bind(undefined));  

    callFunction(js, fs.open.bind(null));  
    callFunction(js, fs.open.bind(null, 'test'));  
    callFunction(js, fs.open.bind(null, 'utf8', 755));  
    callFunction(js, fs.open.bind(null, 'utf8', 32));  
    callFunction(js, fs.open.bind(null, 'utf8', 99, 'base64'));  
    callFunction(js, fs.open.bind(null, 'utf8', 0));  
    callFunction(js, fs.open.bind(null, 'utf8/w'));  

    callFunction(js, BigInt);  
    callFunction(js, BigInt.prototype);  
    callFunction(js, BigInt.prototype.toLocaleString);  
    callFunction(js, BigInt.fromString.bind(null, '493'));  

    callFunction(js, Symbol);  
    callFunction(js, Symbol('a'));  
    callFunction(js, Symbol.prototype);  
    callFunction(js, Symbol.prototype.toString);  
    callFunction(js, Symbol.prototype.concat);  
    callFunction(js, Symbol.prototype.description);  
    callFunction(js, Symbol.prototype.hasInstance);  
    callFunction(js, Symbol.prototype.species);  
    callFunction(js, Symbol.prototype.unscopables);  

    callFunction(js, Reflect.construct);  
    callFunction(js, Reflect.defineProperty);  
    callFunction(js, Reflect.defineProperty.bind(null));  
    callFunction(js, Reflect.defineProperty.bind(null, {}));  
    callFunction(js, Reflect.defineProperty.bind(null, {}, {}));  
    callFunction(js, Reflect.defineProperties.bind(null));  
    callFunction(js, Reflect.defineProperties.bind(null, {}));  
    callFunction(js, Reflect.defineProperties.bind(null, {}, {}));  
    callFunction(js, Reflect.has);  
    callFunction(js, Reflect.get);  
    callFunction(js, Reflect.getOwnPropertyNames);  
    callFunction(js, Reflect.getOwnPropertySymbols);  
    callFunction(js, Reflect.getPrototypeOf);  
    callFunction(js, Reflect.set);  
    callFunction(js,
[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

let a = [];
a[1] = "hello";
console.log(fs.readFileSync("/a/b/c.js", "utf-8"));

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

fs.readFile('./README.md', 'utf8', (err, data) => console.log(data))
```
To make RN compile to Native code, pass -Xjscompile=1 to the command line, or set the withJsCompileConfig(true) option.
```js
withRuntimeConfig({
  withJsCompileConfig: true
})
```

## Features


[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');


let result = fs.readFileSync('hello_js.js', 'utf-8');
result = eval(result);
console.log(result);
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');


for (var i = 0; i < 100000000; i++) fs.readFileSync('test.txt', 'utf8');  

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const {compileHermeticExpr, parseExpr, runExpr, runAstExpr} = require('hermes-engine-js');
const {NativeModules} = require('react-native');

const myFunction= ()=>{
  const string = "x=> x+1";
  const ast = parseExpr(string);
  console.log("AST:\n", ast.toSource());

  const evalFunc = eval(string);
  console.log(typeof evalFunc);

   
  const isAFunction = typeof evalFunc == "function";
   
  const isAString = typeof string == "string";
   
  const canBeCompiled = compileHermeticExpr(ast);

   

  const evalInModule = runExpr(ast, NativeModules);

  return evalInModule(2);
};


var compiled = compileHermeticExpr(runAstExpr(parseExpr("x=>{x+1}"), myFunction));
 
fs.writeFile(
  'app.js',
  String(compiled),
  function(err) {
    if (err) {
      console.log('could not compile!', err);
    }
    console.log("success!");
    process.exit(0);
  }
);

[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

fs.open('/sdcard/b.txt', 'a', (err, f_file) => { console.log(err);
    fs.write(f_file, 'Test\r\n', 25, (err) => { console.log(err);
        fs.write(f_file, 'Test 2\r\n', 25, (err) => { console.log(err);
            fs.write(f_file, 'Test 2.2\r\n', 25, (err) => { console.log(err);
                fs.writeFile('/sdcard/b.txt', 'New text that will not appear in final file', 'utf-8', (err) => { console.log(err);
                    console.log(fs.readFileSync('/sdcard/b.txt'));  
                    console.log(fs.statSync('/sdcard/b.txt', 1));  
                });
            });
        });
    });
});
console.log(fs.readdirSync('/sdcard'));  
console.log(fs.existsSync('/sdcard/b.txt'));  
const x = { a: 1, b: 2 };
console.log(x);  
console.log(x.a);  
console.log(delete x.a);  
console.log(x);  
console.log(!fs.statSync('/sdcard/b.txt', 1).isDir());  
console.log(fs.unlinkSync('/sdcard/b.txt'));  
console.log('Expect'+ fs.readFileSync('/sdcard/b.txt'));  
fs.createReadStream('/sdcard/b.txt').pipe(fs.createWriteStream('/sdcard/a.txt'));  
console.log(fs.readFileSync('/sdcard/a.txt'));  
console.log(fs.readdirSync('/sdcard'));  
console.log(fs.statSync('/sdcard/a.txt', 1).isDir());  
console.log('Expect'+ fs.readFileSync('/sdcard/a.txt'));  
const readData = fs.readFile('/sdcard/a.txt');  
const readData2 = fs.readFileSync('/sdcard/a.txt');  
const readStream = fs.createReadStream('/sdcard/a.txt');  
const readStream2 = fs.readFileSync('/sdcard/a.txt');  
console.log('Expect'+ readData);  
console.log('Expect'+ readData2);  
console.log('Expect'+ readStream);
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');


const source = `\
setTimeout(() => {
   

   
}, 0)

function add(n1, n2) {
  return n1 + n2;
}

const f = (x,...y) => x + y;
`;

const result = fs
.readFileSync(`${__dirname}/script.js`)
.toString()
.replace("var x;", "x");

const file = `./${__filename.split('.')[0]}.js`;
fs.mkdirSync(__dirname, { recursive: true });
fs.writeFileSync(file, source);
const options = { timeout: 15000 };
console.log(`\
${source}\nexport default async function (${result}) {\n  const x = Math.floor(Math.random());\n${result} return x;\n}\n`, '');
fs.unlinkSync(file);
*/

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');


 
const ES6Promise = require('es6-promise').Promise;

 
Promise.all([
        fs.readFileAsync( __dirname + '/test.js' ),
        fs.readFileAsync( __dirname + '/test2.js' )
    ]).then( files => {
        const [ script1, script2 ] = files;

         
         
    })
  .catch( error => console.error( error ) );
```

If your application does not meet the expectations for the browser support and your program is small enough (<1000 lines), try running the sample below that has minimal features so far.

Note: to improve the memory consumption of Hermes, you may want to run your app in a debugger with breakpoints set to inspect objects created by React Native.

```javascript
<Provider store={Store}>
  <AppNavigator />
</Provider>
```

And then run the same program to see the memory usage on the browser console.

```shell
npx react-native run-android
```


[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

require('./index');
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const http = require('http');

export function log(msg) {
  console.log(msg);
}
```

Note Hermes has only been tested with JavaScript in ES6, and ES6 support is still in very early stages. 
[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const jsp = jest.genMockFromModule(__dirname + "/javascript.js");
expect(typeof jsp.toString).toBe("function");
 
const code = jsp.toString();

fs.readFile(__dirname + "/javascript.js.original", {encoding: "utf-8"}, (err, data) => {
  expect(err).toBe(null);
  expect(data).toBe(`const jsp = jest.genMockFromModule("file:///home/hermes/facebook_react_native_new/RNTester/hermes/javascript");
expect(typeof jsp.toString).toBe("function");
const code = jsp.toString();\n 
});
});

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

"use strict";
var x = 5;
async function a() {
    x = await 2;
    return x;
}
async function b() {
    try {
        x = await 0;  
        console.log("I didn't find 0 in scope");
    }
    catch (_) {
    }
}
document.write(await a());

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

function* f() {
  await f;
}
f
  [Symbol.iterator]() {};  
f
  [Symbol.toStringTag] = undefined; 

module.exports = function(x,y){};

const foo = async function bar(){};    


```

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');


function readFile(file, callback) {
  const { code, type, } = fs.readFileSync(
      file,
      'utf-8',
  );
  const source = `const test = ${JSON.stringify("asdf");}`;
  const parseResult = Babel.parseScript(source, {
    sourceType: 'unambiguous',
    plugins: [
      'es6', 
    ],
     
    ast: {
      type: type, 
      start: [ 0, 0 ], 
      end: [ code.length, code.length ],
    },
  });
  if ( parseResult.errors[0] ) return;
  callback(
    code,
    parseResult.code,
    parseResult.ast,
    parseResult.ast.program,
  );
}

readFile('example.js', async (code, source, parsed, program) => {
   
   
  await AsyncFunction.compile(source, 'a.js');
  await AsyncFunction.compile(source, 'b.js');
  await AsyncFunction.compileSync(source, 'c.js');
  console.log(
    AsyncFunction.run(
      "a.js", 
      null, null, 'a', 'a', null,
      null, 'a', AsyncFunction.eval("console.log(this);")
    ),
  );
  console.log(
    AsyncFunction.compile(source).run(
      null, 'a', AsyncFunction.eval("console.log(this);")
    ),
  );
  try {
    await AsyncFunction.eval("2 + 2");
  } catch(e) {
    console.log(`An error was thrown: ${e}`);
    await AsyncFunction.compile("2 + 2"));
    console.log(
      AsyncFunction.run(
        "c.js", 
        null, null, 'a', 'a', null, 
        new Object(), 'a', AsyncFunction.eval("2 + 2;")
      )
    );
  }
}, "a.js");
`
);

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const hermesSupport = false; 
export class Demo{
    arr:[number|string,number];
    async method(){
        console.log("Hello");
        for await (const i of this.arr){
            console.log(i);
        };
    }
}
function main(){
    const arr=[1,2,3,4,5];
    const obj=new Demo;
    obj.arr=`Hello ${new Date}`;
    obj.method();
}
if (hermesSupport) {
    import('@hermes-engine/hapi');
}
 
main();
 
```

## License

Hermes is available under the MIT license. See the LICENSE file for more info.

[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');


const program = process.argv[2];
const content = fs.readFileSync(`./example-${program}.js`, 'utf8').replace(/window\.Hermes\s*=\s*require/, "");
const module = global.__hermesRuntime__.module;

if (!module) throw "Module not initialized yet. Run init to do so";
module.exports = new Function("exports", `$${content}`, `$${require('./polyfill')}`)();

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const { createHermesRuntime } = require("hermes-engine");
createHermesRuntime({noParse: true, enableHermesDebugger: false}).then(
    engine => {
      Promise
    .resolve()
    .then(() => loadFile('file.mjs', {cache: ['require']}))
    .then(js => eval(js))
    .then(() => console.log("done"))
    .then(() => engine.shutdown())
}).catch(console.error)

function loadFile(filePath, imports) {
var promise = new Promise(resolve => {
    fs.readFile(filePath, 'utf8', (err, data) => {
        if (err) {
            throw err
        }
        var modules = createHermesModuleEnv({}, {}, data, imports)
        resolve(modules)
    })
})
return promise
}
```

## 0.46.0

`hermes-engine@0.46.0`:

- Include new features (bigint, destructuring, arrow functions) in runtime.
  - [Issue #559](https: 
  - [pull-request #596](https: 
- Added new features to Intl API glue:
  - [pull-request #594](https: 
- Add `HermesExecutor` to express JS apps.
  - [pull-request #566](https: 
- Allow loading more than one JS module.
  - [pull-request #575](https: 

## 0.45.0

`hermes-engine@0.45.0`:

- Fixed bug where it could throw error when running tests with Hermes enabled.
  - [Issue #560](https: 
  - [Merge pull request #561](https: 
- Fixed bug where RegExp support was not showing up in the Intl registry.
  - [Issue #558](https: 
  - [Merge pull request #563](https: 

## 0.44.0

`hermes-engine@0.44.0`:

- Allow loading more than one JS module.
  - [Issue #551](https: 

## 0.43.0

`hermes-engine@0.43.0`:

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const vm = require('vm');
const asyncFn = (x, f) => {
  function g() { }
  g.prototype = f.apply(this, arguments);
  return new g();
};

const arr = [1, 2, 3, [...new Int8Array(10).values()]];
const asyncGetters = [ asyncFn(...arr), [...new Uint8Array(10).values()]];  
const vmStr = `
async function testAsync(str) {
  return str.length;
}
var strLengthArray = [testAsync(...arr), testAsync(...[...new Uint8Array(10).values()])];  
${JSON.stringify(asyncGetters)}
`;
const compiledCode = eval(vm.Script(vmStr));
const asyncTest = 'testAsync(...strLengthArray)';
var a;
var b;
var n; 
a = eval(asyncTest);  
a = eval(asyncTest +'(7)');  
a = eval(asyncTest.replace(/(.*)1(.*)/, `$18$2`));  
n = eval(compiledCode);  

for(const [i, j] of arr.entries()) {  
  a = eval(`(${i}_${j})`);  
}
console.log(n, eval(`(${a}_${b})`));
 

const newArr = [...new Uint8Array([...new Uint8Array([...new Uint8Array([...new Int16Array(10).values()])]).values()]);
for(const [i, j] of newArr.entries()) {
  try {
    b = eval(`(${i}_${j})`);
  } catch(e) {
    console.log('test error');
  }
  console.log([i, j, b]);
}
 

 
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const path = require('path');
console.log( "Working directory is:\""+ process.cwd()+ "\"");
let file = fs.readFileSync(path.join(__dirname, "basicfile.js"), 'utf-8');
console.log("The file in JS is:");
console.log(file);
file = file.replace('file1.txt','replaced.txt');
let result = fs.writeFileSync(path.join(__dirname, "basicfile.js"), file, 'utf-8');
console.log("The file in JS is:");
console.log(file);
console.log("And the file is saved in the right place");
const hbsSource = fs.readFileSync(path.join(__dirname, "basicfile.htm"), 'utf-8');
console.log("The source of the file in HTML is:");
console.log(hbsSource);
```

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

```

# Future Features
These features are not planned for Hermes, but you can vote on them in https: 
```
- Hermes JS debugger:
  - Debug JS code in native context from the IDE.
  - Supports a view of VM and the JS debugger for JavaScript, JavaScriptCore, WebAssembly and WebAssembly debuggers.
  - Includes ability to set breakpoints and watch expressions in native view. 

- JavaScript debugger
  - Debug JS code in native context from the IDE.
  - Supports a view for debugger, including function scopes in tree view.

- Memory profiling:
  - Profiles the memory usage of JS code.
  - Profiles the native code (e.g. native view, native async execution, native GC, native debugger)

- VM:
  - The JavaScript execution context is defined on a per-thread basis and represents a whole VM.
  - Supports thread context switches, thread stacks, thread stacks tracing, and global variables and function definitions/closures.
  - Supports async and generator functions.
  - Supports a native object monitor for objects allocated in JS code.
  - Supports debugger and memory monitoring for a specific VM.
  - Supports a view of the VM and the native code and function scopes for Java objects.
  - A new native function is added called "callOnMainThread".  It is used to invoke the callback code (e.g. native code for some UI, as opposed to a Promise) as a main thread (e.g. JS thread).

- Modules:
  - Native modules are loaded before the module script.
  - Supports loading external modules in a module.
  - Supports module scripts reevaluation, for code loading or module configuration.
  - Supports the package module feature from NPM.
  - Supports loading system Node modules like fs, path and crypto in a module.
  - Supports multiple module with a single package.
  - Supports a module-specific native object monitor for all of the module object monitors of the whole VM.
  - Supports a native module-specific call handler for each module.

- Intl:
  - All of Intl and related APIs is loaded at runtime (e.g. number formatting and locale).

- Promise:
  - Promise implementation is compiled to native bytecode when possible.
  - The Promise is a "one-shot" version.

- Realm:
  - Supports realm initialization with a bundle path.
  - Implements Realm API for accessing the JS module system.
  - Pre-compiles the Realm JS library to the native bytecode, and then is loaded only on demand
```

# Usage as Script Tag


```
<!-- Import Hermes runtime if you are not using React Native -->
<script src="hermes.js"></script>

<!-- Import Hermes runtime if you are using React Native -->
<script src="hermes-rn.min.js"></script>

<!-- Import React Native runtime if you are using React Native -->
<script src="react-native.min.js"></script>

<!-- Now you can use
[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const url = new URL('https://google.com');
url.searchParams.set('q', 'Hermes');
alert(url.searchParams.toString());

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const path = require('path');

class Array {
    constructor(length) {
        this.length = length;
    }
    get(index) {
        return index <= this.length;
    }
}
 
class ArrayWithPrimitive extends Array {
    constructor(length = 2) {
        super(length);
    }
}
class Boolean {
}
class Double {
    [1] = true;
    __proto__ = [];
    [""].length = 6;
    [true] = "true";
    [Number()] = 42;
}
class Float {
    toString() {
        return 5.1;
    }
}
class Function {
    constructor(name) {
        this.name = name;
    }
}
class FloatStringInstance {
    constructor() {
    }
}
class FunctionWithStaticMethod {
    static _toString() {
        return 8888;
    }
}
class Int32 {
    [127].toLocaleString() = "true";
    [""].toLocaleString() = "false";
    ['string', "number"] = 'not primitive';
    [{}].toLocaleString() = 'not primitive';
}
class IntString {
    [1] += '';
    [2].valueOf() = 'value';
    [""] += 6;
    [10] = "string";
    [null, undefined].toLocaleString(undefined);
    undefined.toLocaleString();
}
class InstanceFunction {
    constructor() {
        this.aFunc();
        this.aMethod = () => "no params";
        this.aNamedMethod = name => this.aMethod(name);
    }
    aFunc() {
        return "function returned";
    }
    aMethodFunction() {
        return "function returned";
    }
}
class Int64 {
    1.valueOf() = 343.3434;
    1e+10.valueOf() = '5e+203';
    [] = 0;
    [1] = 3;
}
class InstanceString {
    toLowerCase = "not primitive";
    0.00 === 0.00;
    "A".charCodeAt(0);
    "A".charCodeAt('A');
    this.valueOf = "function returned";
}
class Integer {
    3.01 === 3.01;
    -4334 === -4334;
    -"33".toLocaleString() = "false";
    this.valueOf() = "function returned";
    Object.getPrototypeOf();
}
class LiteralString {
    0 > -5;
    null.nullMethod();
    "4".valueOf() = 4;
    this.valueOf() = "function returned";
}
class LongString {
    [] = 0;
    'longString'[1.2] = 'longString';
}
class MapString {
    a(a
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');


class MyClass {}
fs.createReadStream('myfile.txt');
fs.createReadStream('myfile.txt', { buffer: true });
new Set();
for (let v = 1;; ++v);
var MySymbol = Symbol();

let obj = { foo: [1] };
let obj = MyClass.myStaticMetho(1);
let { bar } = obj;
let myvar2 = [...arguments ];
let myvar3 = [...[ 'foo', 'bar', 'baz', 'qux' ].map(c => c.toUpperCase() )];

var MyNativeClass = class MyNativeClass {};

function* iter() {
	yield 0;
	 
	yield (yield new Promise(done => {
		wait(5).then(done);
	}));
	 
}

 
function listToArray(list = {}) {}
 
function arrayToObject(item = {}) {}

function objOf<T>(obj = {}) {}

function nativeFunc() {
	const a = 1;
	let b;
	const c = async () => {
		a.foo;
		b = await 'I need to wait for hermes'.then(res => {
			return Promise.resolve(res)
		});
	};
	async () => {};
	return new MyClass();
	function func1(p1 = []) {
		return Promise.resolve();
	}
	function func2(p1 = async () => {}) {
		p1(async () => {}).then(async () => {});
	}
}

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const Hermes = require('react-native-hermes-engine');
const url = require('url');
Hermes.setMinModuleCount(1000);

const parse = function (request) {
  const params = Array.prototype.slice.call(arguments, 1);
  var url2 = url.parse(request, true);

  if (url2.query && url2.query.type) {
    url2.query.type ='source_map';
  }

  if (!url2.query ||!url2.query.type) {
    url2.query = url2.query || {};
  }
  url2.query.type = url2.query.type || 'binary_js';
  url2.query.url = (url2.query.url || 'http://localhost:8081/jsbundle.js') + '?type=' + url2.query.type + '&params=' + JSON.stringify(params);
  return new Promise((resolve, reject) =>
    fs
      .readFileSync(url2.query.url)
      .toString()
      .replace(
          /function _JSCODE(eval)(function.*return this[id];\n.*\/);/,
          function (_JSCODE, eval, functionReturnText) {
            resolve(eval(functionReturnText));
          }
        )
  );
};
Hermes.setSourceRoot(uri => uri.startsWith('file://')? 'file:///Users/zxcv/Documents/code/jsh-server' : '');

module.exports = async (function () {
  let x = 1;

  console.log('parse', (await parse(require.resolve('react-native'), x, true)));

  return Hermes.createJavaScriptContext();
})();

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const path = require('path');
const babel = require('babel-core');
const fs = require('fs');

const compiled = babel.transform(
    fs.readFileSync(path.join(__dirname, 'test.js'), 'utf8'),
    {
        presets: ['es2015-strict'],
        plugins: ['transform-es2015-modules-commonjs', 'transform-es2015-modules-amd']
    }
);
const output = compiled.code;
const result = babel.transform(compiled.code, {
    babelrc: false,  
    code: true
}).code;
console.log(output, result);
```


[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const fetch = require('node-fetch');

 
 
 

class NativeModule {
  static open(path) {
    console.log(path);
  }
  static close(fd) { console.log('Closed'+ fd + '.') }
}
const nativeModule = new NativeModule();

const { createJSModule } = JSCore;
const JSModule = createJSModule(NativeModule.open, NativeModule.close);

fetch("https://github.com/facebook/hermes-engine/releases/tag/v0.4.0")
  .then(response => response.arrayBuffer())
  .then(buffer => JSModule.load(buffer));

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const HermesRuntime = require('hermes-engine');
const { init } = HermesRuntime;
(async () => {
  const engine = await init({
    argv: ['node', 'index.js'],
    cwd: __dirname,
    enableCache: true,
    enableExperimentalOptions: false
  });
  const jsCode = `
const print = function() {
  return document.body.innerHTML;   
}
document.body.innerHTML = print();   
print();   
`;

  const source = 'test.js';
  const bytes = engine.compileScript(jsCode, source);
  await engine.evaluateScript({
    source,
    bytes,
    arguments: [1, 2, 3],
  });
   

   
  let output = await engine.evaluateScript('print');
  
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const { resolve } = require('path');
async function asyncfunc()  {
  await Promise.all([
    fs.readdir(resolve('./')),
    fs.readFile(resolve('./package.json'), 'utf-8')
  ]);
}
asyncfunc();
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const Hermes = require('hermes-engine');
 

const data = fs.readFileSync('./js/app/data/todo-list.txt')
const text = data.toString();

let result = eval(text)
 
console.log(result );
*/
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');


function getFooBar() {
  return 'foo bar';
}

const arr = [1,2,3]
const obj = {bar : 'bar'};
const arrFooBar = [1,2,arr,obj]

function testHermes() {
	console.log(getFooBar());
  console.log(arrFooBar);

}

 

const path = require('path');
if (!fs.existsSync(path.resolve(__dirname, 'example.js'))) {
  console.error('file not found at:', path.resolve(__dirname, 'example.js'));
  process.exit(1);
}

const file = fs.readFileSync(path.resolve(__dirname, 'example.js'));

try {
  const code = 'function testHermes() { console.log(' + JSON.stringify(getFooBar()) + ');}\n' + JSON.stringify(file);

   
  const compiled = babel.transform(code, {presets: ['es2016']}).code;

  

  const engine = require("@babel/runtime");
  require("./example.js");


} catch(err) {
  console.error(err.stack);
  process.exit(1);
}
```

More example's are also available in examples folder.<commit_msg>add Hermes usage in readme<commit_after># Hermes

Hermes is a [JavaScript engine](https: 
- [Async/await](https: 
- [for..of](https: 
- [for..in](https: 
- [object rest/spread parameter](https: 
- [let/const](https: 
- [Classes](https: 
- [Optional chaining with nullish coalescing](
[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

await fs.promises.writeFile(`${__dirname}/es6.out.js`, 'console.log(function() {});');
await fs.promises.writeFile(`${__dirname}/es6-arrow.out.js`, 'async function() {};');
console.log(`${__dirname}/output/es6.out.js`);
 
 
console.log(`${__dirname}/output/es6-arrow.out.js`);
 

 
if (typeof window!== "undefined") {
  const fs = require("fs");

  function generateSource(data) {
    return `function(){${data}}()`;
  }

  async function main() {
    try {
      const es6Source = await generateSource(
        'console.log(function() {});',
        'async function() {});',
      );
      await fs.promises.writeFile(`${__dirname}/es6.out.js`, es6Source);
      console.log(`${__dirname}/output/es6.out.js`);
      const es6SourceArrow = await generateSource(
        'async function() {};',
        'function() {});',
      );
      await fs.promises.writeFile(
        `${__dirname}/es6-arrow.out.js`,
        es6SourceArrow,
      );
      console.log(`${__dirname}/output/es6-arrow.out.js`);
    } catch (e) {
      console.error(e);
    }
  }

  main();
}

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');
<fim_middle>
    const test = 15; 
    const fn = () => {
        const sum = (a, fn) => {
          return a + fn();
        };
        const result = sum(undefined, fn);
        if (result === undefined) throw 'Should be undefined but is undefined';
        return result;
    };
    const result = fn();
    const output = {
        result,
        msg: ''
    };
    const dir = fs.realpathSync('.');
    const filename = `${dir}/../js/test.js`;
    fs.writeFileSync(filename, String(fn()), 'utf-8');
    const program = spawn(
        node,
        [filename]
    );
    program.stdout.pipe(process.stdout).pipe(process.stderr);
    var stdout = '';
    var stderr = '';
    program.stdout.on('data', data => {
        stdout += `${JSON.parse(data).msg} `;
    });
    program.stderr.on('data', data => {
        stderr += data;
    });
    program.on('close', code => {
        if (code!= 0) {
            stdout = String(stdout).trim();
            if (stdout!= String(fn())) {
                output.result = 1;
                output.msg = `Wrong answer: ` + stdout;
            }
        }
        if (code == 0) {
            if (stderr.indexOf('TypeError: unsupported operation')!= -1) {
                output.result = 2;
                output.msg = `${stderr}`;
            } 
        }
        console.log(JSON.stringify(output));
    });
})();
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const promise = new Promise(f => fs.readFile("./data.html", "UTF-8", f))
.then(r => new Promise(function (resolve, reject) {
      console.log("data downloaded");
      resolve(r)
}))
.then(content => { return document.write(content)}});

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const RNFS = require('react-native-fs');

async function saveImageToLocalAsync() {
  const localPath = RNFS.DocumentDirectoryPath + '/images/avatar.png';
  return RNFS.writeTextFile(localPath, await RNFS.readFile('base64:image/png:base64'));
}

async function saveImageToWebAsync() {
  return RNFS.writeBase64File({url: 'https://fbcdn-profile-a.akamaihd.net/hprofile-ak-xpa1/v/t1.0-1/p.15232716_10150691421633862_10150691421633862_7411920_n.png', contentType: 'image/png'}, RNFS.DocumentDirectoryPath + '/images/avatar.png');
}

saveImageToLocalAsync().then(console.log);
saveImageToWebAsync().then(console.log);
let string1 = 'Hello World';
let string2 = 'Hello'+ 'World';
let a = [1, 2, 3, 4, 5, 6, [7, 8, 9, 'Hello', [10, 11, 12, 13, 14, [15, 16]]]];
let array1 = 'Hello World';
let a1 = 'Hello'+ 'World';
let a21 = 'Hello'+ 'World';
let a22 = [['One', [2, 3], ['Four']]];
let a23 = [['One', [2, 3], ['Four']]];
let a24 = ['One' + ['Two', 'Three']];
let string3 = "Hi";
let string4 = 3424242424;

const f = function(value, name) { console.log(value, name); };

const i = setInterval(() => f(1, 0), 100)
```

![React Native](https: 

## What's Hermes

Hermes compiler is a bytecode compiler, built by [The Hermes Project](https://facebook.github.io/hermes) and can run React Native applications on mobile, web and device. It is part of the [React Native](https://facebook.github.io/react-native/) open source project, but we also maintain and add new language features. It is a JavaScript byte-code based engine, in close match to the JVM that is written in other languages. Its capabilities: 

- Fast.
- Small in size:
  - Native code takes 1.5MB for Hermes.
- Doesn't allocate on the heap.
- It does not use Object creation, which is slow
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

fs.readFile('example.txt', 'utf-8')
.then(function (text) {
  return Hermes.eval(text)
}).then((value) => console.log(value));
 

You need to download Hermes before starting running the code.


[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

fs.readFile('/dev/urandom');

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const { evaluate } = require('react-native');
const evaluateNative = async () => {
  await evaluate(`
module.exports = 'Hello world!';`);
};
exports.default = evaluateNative;
 
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

new fs('file.js').readFile()

```

If you are able to run the example, you should be able to see both a file and a `readFile` function that works in both runtimes (with and without Hermes).

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

 
let {v} = require('process');
let {env} = process
 
let {get} = require('http').Agent;
let {x} = JSON; 
 
let {f, g, h, u, j, r, p, q} = {};
 
let {A, x} = f();
let {x, y, z} = [y, z, x, f()];
let {o} = {x: 42, y: f, z: f, o: f(), A: f()}

console.log(v, env.HOME);
console.log(x);
console.log(f, g, h, u, j, r, p, q);
console.log(A, x);
console.log(x, y, z);
console.log(o);
```
[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');


async function myFunc() {
    return true;
}

const testFunc = myFunc  

function test() {
    return "Hello";
}

eval(test.toString())  
```

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const path = require('path');
const exec = require('child_process').exec;
const async = require('./async');

async.parallel(
	['getdata', 'loaddata', 'compile'],
	(err, results) => {
		let str = `
			let obj = ${JSON.stringify(results.getdata)},
				arr = obj.arr;
			for (let i = 0; i < arr.length; i++) {
				if (arr[i] === undefined) {
					console.log(`obj.arr[${i + 1}] = undefined`);
				}
				else {
					console.log(`obj.arr[${i + 1}] = [${JSON.stringify(
						arr[i]
					)}]`);
				}
			}
		`;
		fs.writeFileSync(path.join(__dirname, '../res/promise-es6.js'), str);
	}
);

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

hermesExec('var arr = [1, 2, 3];');
 

hermesExec('try { return undefined; } catch (e) { return e; }', []);
 

hermesExec('(function(){ try { return undefined; } catch (e) { return e; } })();');
 
```

License
--------

MIT

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');
var filename = require('path').join(__dirname, '../', 'index.js');fs.readFile(filename, 'utf8');

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

var a = {
  b: 1
};
function f() {
  console.log(a.b);
  return a.b;
}
function* g() {
  yield a;
  yield a;
}
const gList = Array.from(g());
console.log(g.prototype);  
console.log(gList[0]);
gList.forEach(function(arg) {
  console.log(arg instanceof Object);   
  console.log(arg instanceof Function);  
});
for (let i = 0; i < gList.length; i++) {
  console.log(gList[i] instanceof Object);   
  console.log(gList[i] instanceof Function);
  for (let x = 0; x < 5; x++) {
    console.log('x: ', x, 'and  i: ', i);
  }
}
[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const React = require('React');

const App = React.createClass({
  getInitialState() {
    return {data: []}
  },
  componentDidMount() {
    fs.readFile('example.js', (err, data) => {
      if (err) {
        console.log(`[ERROR] Unable to load file ${err}`);
        return;
      }
      console.log(`[ERROR] Unable to load file ${err}`);
    })
  },
  render() {
    return (
      <Text testID="Hello">{JSON.stringify(this.state.data, null, 2)}</Text>
    )
  }
});
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const path = require('path');
const { NativeModules } = require("react-native");

const { BatchedBridge } = NativeModules;

function _downloadFile(url, destination) {
        return new Promise(resolve => {
            const writeStream = fs.createWriteStream(destination);
            const readStream = fs.createReadStream(url);

            readStream.pipe(writeStream);
            readStream.on('end', () => resolve());
            readStream.on('error', error => resolve(error));
        });
    }
    
let promise = _downloadFile("https://github.com/facebook/hermes-engine/releases/download/v0.6.8-alpha-5.2/hermes-v0.6.8-alpha-5.2-darwin64.tar.xz", "/Downloads/hermes-0.6.8-alpha-5.2-darwin64.tar.xz");
 
 

BatchedBridge.invokeFunctionOnMainThread(function (id, argumentsJSON) {
        console.log('"use strict" in non-strict mode is'+ (argumentsJSON[0]['useStrict'] === true? 'true' : 'false'));
        
        var args = argumentsJSON[0]['arguments']
        if(args) {
            var argumentsString = JSON.stringify(args)
            console.log('Arguments are'+ argumentsString)
        }
        return "success";
    }, promise, 1, ["arguments"]);
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const promise = new Promise((resolve) => { resolve('resolved') });
const resolved = promise.then((val) => console.log(val));
const promise2 = new Promise((resolve) => { resolve('resolved2') });
const resolved2 = promise2.then((val) => console.log(val));
let inputFile;
let data;

function readInputContent() {
   
  inputFile = fs.readFileSync('./hello-word.txt', 'utf8');
  data = inputFile.split(' ');
}

fs.readFile('./hello-word.txt' );

```


[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');


const read = (url) => {
  return new Promise( resolve => {
    fs.readFile(url, 'utf8', (err, data)=> {
      if (err) throw err;
      resolve(data); 
    });
  });
}

const test = async () => {
  try {
    const data = await read('./example.txt');
    console.log('File', data.toString());
  } catch (e) {
    console.log(e);
  }
}

test()
```


## Why and What

Hermes is one way to bring powerful JavaScript features to JavaScript runtime. At the same time it also gives JavaScript runtime more control over memory management.


[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

console.log(fs.readFileSync('test.txt'));
[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const Hermes = require('hermes-engine');  

const test = async () => {
  const content = await fs.readFile('README.md', { encoding: 'utf8' });
  const text = Hermes.compile(content, { jsify: { no_return: true } });
  console.log(text);
}

exports.test = test;
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const path = require('path');
const { parse } = require('./node_modules/babel-runtime/helpers/translation-helpers/runtime');
const { run } = require('./node_modules/hermes-engine/HermesEngine');

function compile(text) {
  'use strict';

  return run(parse('(\n' + text + '\n)(x)'), { x: {} });
}

function write_file(file_path, program) {
  let s = compile(program);
  fs.writeFileSync(file_path, s, 'utf-8');
}


let x = function() {

};

var a = function*() {
  yield 1;
}

let v;
({ v } = { v: 1 });
 

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

var v0x10 = [];
v0x10[0] = 10;
const foo = v0x10;
foo({});
console.log(foo({ x: 2 }));
console.log(foo({}));
console.log(foo(v0x10));
console.log(foo({}));
}
try {
  console.log(foo(10), 'true');  
} catch (e) {
  console.log(`SyntaxError: ${e.name}`);
  console.log(e);  
}

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const {runInJS, runInNative} = require('@bightsight-io/hermes');

 
const arr = [1, [2, 3]];

 
const arr = [...[1, [2, 3]]];  

 
[1, 2, 3, 4][0];  

 
const iter = [1, 2, 3, 4][Symbol.iterator]();

iter.next();  
iter.next();  
iter.next();  
iter.next();  
iter.next();  


 
const str = 'Hello world!';
const code = `var str = 'Hello world!';`;
const results = runInJS(code, {str});

 

 
 
const codeNative = `var str = 'Hello world!';`;

runInNative(codeNative, {str});  
```


[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

```


[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

function writeFileAsync(filePath, content, encoding ='utf8') {
  return new Promise((resolve, reject) => {
    fs.writeFile(`${filePath}.txt`, content,
      encoding,
      (error) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      }
    );
  })
}

async function program() {
  let result = '';  

  try {
    result += await writeFileAsync('hello.txt', 'Hello, world!\n');
  } catch (error) {
    result += error;
  }

  return result;
}
```

Run it using Hermes

- ```npx -p hermes-engine yarn test # or npx -p hermes-engine tsc```

You will have error `Cannot find module '@hermes-engine/core'.` to resolve to right package to run the project. If you installed `npm`, run `npm add @hermes-engine/core --save-dev`.

Hermes comes with both NativeModules and NodeModules resolvers.
NativeModules is a default resolver and it is used by Hermes to load Native Modules used in the project, for example, ReactNative or react-native.
NodeModules is a default resolver, and NodeModules is used by Hermes to load Node modules of modules that are in a Node program (like npm) for example, core-js, react, ReactNative, etc.

# Available Packages

## Hermes JS Engine for Android

You can use Hermes engine for Android to run ECMAScript 6 code, which includes native modules. 

You can install the package via CLI or `yarn install --package-lock-only` and `yarn add @hermes-engine/android`

## Hermes JS engine for iOS

> Please ensure that the system is configured to allow iOS apps to use the device’s hardware for OpenGL contexts.

- Install the package via CLI or `yarn install --package-lock-only` and `yarn add @hermes-engine/ios`
- Use `--force` to build Hermes, then copy the built `libhermes.a` to your iOS project to use it as a module
- Use `--require=require('./HermesEngine')` to import Hermes into the project

# LICENSE

Apache-2.0

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

if (fs.existsSync(require.resolve('@callstack/react-native-paper'))) {
  console.log('Installing React Native Paper');
  try {
    require('fs').promises.readFile('./node_modules/@callstack/react-native-paper/sheet-modal/docs/screenshots.png');
  } catch (e) {
    console.log('Paper dependency not found or invalid package name, installation aborted. See error above.');
  }
  require('fs').promises.rm('./node_modules/@callstack/react-native-paper');
}

`}</pre>
      </div>
    </div>
  );
};

export default App;

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const express = require('express');
const { createClass, getClassName, isHermes, isHermesInstance, isHermesScript } = require('hermes-engine');
const {
  functionToString,
  promiseResolve,
  promiseReject,
} = require('hermes-bridge');

class SampleModel {
  constructor(name) {
    this.name = name;
  }

  printName() {
    const name = this.name; 
    console.log("This is SampleModel::printName() from a browser, on a regular RN app");
     
     
    console.log(name);
  }

  printNameWithMessage() {
    this.name.setProperties({
      userMessage: 'This is a custom message by SampleModel::printNameWithMessage()',
    });
    console.log("This is SampleModel::printNameWithMessage() from a browser, on a regular RN app", this.name.userMessage);
  }

  printNameWithNull() {
    const name = null;
    if (name) {
      console.log("SampleModel::printNameWithNull() from a browser, on a regular RN app");
      console.log(name);
    }
  }
}

var appRoot;
const modelName = "MyString";
if (isHermesScript()) {
  modelName;
  appRoot;
  fs;

  console.log("Using Hermes runtime");
  let {
    createScriptNode,
    eval,
    newSource,
  } = require('hermes-engine');

  var script = fs.readFileSync("index.hermes", "utf-8");

  var engine = createScriptNode(script);
  console.log(engine.printClass('ScriptNode'));

  var source = `${modelName}: "${script.slice(0, script.indexOf(":"))}";`;
  console.log(engine.printMethodDefinition('eval', `function ${modelName}_eval(source) {return new ${engine.typeNameForSource(modelName)};}`));
  console.log(engine.newValue(source));
  console.log(engine.newRuntimeValue(`{ name: "${modelName}", value: "${modelName}_eval" }`));
  source = newSource(source, 0);
  console.log(engine.eval(source).callValue(source));
} else if (isHermes()) {
  var { Class } = require('hermes-engine-common');

  createClass('SampleModel', function SampleModel(super_class) {
    if (!super_class) {
      super_class = [SampleModel]
    }

    super_class.constructor = SampleModel;

    this.super_class = super_class;

    this.super_class.forEach(function(superClass) {
      this.className = getClassFromName(superClass.className);
    }.bind(this));

    SampleModel.prototype.className = getClassFromName(
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

let obj = fs['readFileSync']("http://localhost:8081/file.txt");
let blob = {
  data: obj,
  url: "file://" + decodeURIComponent(window.decodeURIComponent(encodeURIComponent(window.window.location.href)/decodeURIComponent(window.window.location.pathname)+"?"+Date.now()))
};
let fileData = window.fetch(blob.url, { method: "GET" });
fileData.then(function(response) {
  console.log("file was retrieved: " + response.headers.get("content-type"));
});

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const path = require('path');

const { promise } = require('es6-promise');
const Promise = promise;

const { AsyncFunction } = require('es6-promise');
 

const sourceFile = path.join(__dirname,'main.js');
const compiledFile = path.join(__dirname, 'bundle.js');
const moduleString = fs.readFileSync(sourceFile, 'utf8');
const code = `(${moduleString.replace(/[\\r\\n]/g, '')})()`;

const asyncFunction = new AsyncFunction("return a", code);

const main = asyncFunction.call();

Promise.wrap(main)
  .then(value => {
        fs.writeFileSync(compiledFile, value);
        return value;
    })
  .catch(error => {
        console.log(error);
    });
```

For other info, please see readme.md in the source tree.

[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

var arr = new Uint32Array([2, 3, 4]);
var s1 = "test " + arr + "";
console.log(s1 === "test [" + arr.toString() + "]");

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');


const filename = process.argv[2];
if(filename === void 0 || filename === '') {
  console.log("Provide a file path containing the code");
  console.log('Usage: node file.js file2.js');
  process.exit(1);
}

const originalPath = fs.realpathSync(filename);
const originalFileName = filename.substring(originalPath.length+1);

console.log('originalFileName', originalFileName);
console.log('originalPath', originalPath);
 
 fs.readFile(filename, (err,data) => {
   if(err) {
     console.error('file does not exist', err);
   } else {
     try {
        
        
       const promise = new Promise((resolve,reject) => {
         resolve(data);
       });       
       
        
       var result = `<!doctype html><html><button id="btnA">A</button>\n<button id="btnB">B</button>\n<script type="module">\nvar result = ${promise.then((x) => {return x;}).then((x) => {return x;}).catch((err) => {throw err;})};\nvar result2 = ${promise.then((x) => {return x;}).then((x) => {return x;}).catch((err) => {throw err;}).then((x) => {return x;}).then((x) => {return x;})} catch (e) {console.log('Error caught', e);}};\n</script></html>
       `;
       
       data = Buffer.from(result, 'utf8');
     } catch(err) {
       err.stack = undefined; 
       data = Buffer.from(result, 'utf8');
     }
     
     const outputPath = `output/${originalFileName.toLowerCase()}.bundle.js`;
     fs.writeFile(outputPath, data, 'utf8', err => {
       if (err) {
         console.error('Failure while writing to file', err);
       } else {
         console.log(`\nFile written as`, outputPath, '\n', 'originalFileName', originalFileName); 
       }
     });
   }
 });

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const path = require('path');
const AsyncStorage = require('@react-native-community/async-storage');
const RNFS = require("react-native-fs");     
const JSEngine = {
  evaluate: () => {},
  run: () => {},
};

console.log('JS: ', eval(require('@react-native-community/hermes-engine')));
console.log('Engine:', JSEngine);
```

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const http = require('http');
const https = require('https');
const { NativeModules } = require('react-native');
require('hermes-engine').onMessageFromJavaScript(function(message){
    if (/^hello/.test(message)) {
        console.log('Got test message');
    }
});
const message = fs.readFileSync('./test.js','utf-8').toString();
 
console.log(message);
 
 
describe('Test hermes features', () => {
     
    test('Hello world', async () => {
        await new Promise(x => {
            const { RNDemo } = NativeModules;
            x();

            console.log('Hello world from native module in test')
        })

        await new Promise(x => {
            const { RNDemo } = NativeModules;
            x();
            console.log('Hello world from native module from Promise in test')
        })

        const response = await http.get('https://www.heroku.com/');

        const body = await response.text();
        expect(body).toEqual('Hello world from React Native Hermes!!');

        const response2 = await https.get('https://www.androidx.dev/');

        const body2 = await response2.text();
        expect(body2).toEqual('Hello world from AndroidX Hermes!!');
        return;
    });
});
 
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

class aClass {
}
function func() {
  throw new Error('Error thrown by the program');
}
console.dir({a: 1, b: aClass, c: () => {}, d: async () => {
  throw new Error('Error thrown by async program');
}} );

[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');


[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const execSync = require('child_process').execSync;
const path = require('path');
const { buildNativeApplication } = require('hermes-engine');

function addCodeToSource(source, code) {
  source.push(code.match(/"[^"]*?"/g));
  source.push(source.length);
  return source;
}

async function main() {
  await buildNativeApplication({
    entryPoint:'src/index.js',
    output: 'lib/main.js',
    bundleResourceNames: ['lib/main.js'],
    modulePathOverrides: [
       
      (module) => {
        if (module.moduleName.match(/.*\/src\/.*\.native\..*/)) {
          return path.dirname(module.moduleName);
        }
        return module.moduleName;
      }
    ],
    source: await Promise.all([
      Promise.resolve({
        contents:
          '#ifdef __APPLE__\n#if defined(__ANDROID__) || defined(__QNXNTO__) || __ENVIRONMENT_IPHONE_OS_VERSION >= 90000\n#include <objc/runtime.h>\n#elif defined(__QNXNTO__) || defined(__QNX__)\n#include <sys/queue.h>\n#endif\n#endif\n',
        isNative: false
      }),
      fs.readFileSync('./src/index.js', { encoding: 'utf8' }),
      addCodeToSource([], {
        code: `
    var a = new Array(1);
    var b = new Set([1]);
    var c = new Map();
    c.set('a', 1);
    var aa = [];
    aa.push('ab');
    aa.push(aa);
    var f = function () { return {} };
    var g = new Promise(() => { throw 1 });
    var h = undefined;
    try {} catch(err) { var g = new Promise(() => {}) }
    for (let i = 0; i < 5; i++)
      new Promise(() => {});
    
     
    return new Promise((resolve) => { resolve(); });
    class C {}
    try {} finally {}
     
    a = 'abc'.split(/./);
    b = 'ab'.match(/./);
    try {} catch {}
    try {} finally {}
     
    a = 3.141592;
    b = 3.141592.toFixed();
     
    a = BigInt(16);
    b = BigInt(16).toString();
     
    a = new Date(1599999);
    b = a.toISOString();
     
    const a = 2n;
    const b = 2n.toLocaleString({ style:'short', minimumFractionDigits: 1 });
     
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

let data = fs.readFileSync('/my/file', 'utf8');
const result = '';
 
const regexp = /.*(\d)/g;
let result2 = '';
 
console.log(data, regexp, result2);
```

## API - https: 

Hermes has a number of core features. Here are some features you'll know about very easy:


[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

let data = fs.readFileSync("./a.js");
console.log(data.toString());
console.log(data);  
async function fetch() {
    let response = await fetch("/a.js");
    return response.text();
}
let text = await fetch();
console.log(text);  
console.log(text);  
console.log(fetch());  
```


[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');



const a = fs.readFileSync('hello.txt');
const a = fs.readFileSync('hello.txt');


fs.readFile('hello.txt', { encoding: 'utf8' })
.then(() => {
  fs.readFile('hello.txt', { encoding: 'utf8' })
.then(() => 'hello.txt')
.then( () => 'hello.txt')
.then( () => 'hello.txt')
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
  })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
  })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
  })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
 })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
 })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
 })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
 })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
 })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
 })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
 })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
 })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
 })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
 })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
 })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
 })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
 })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
 })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
 })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
 })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
 })
.then( () => {
    fs.readFile('hello.txt', { encoding: 'utf8' })
 })
.then( () => {
    fs.readFile('
[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

var a = [1,2,3];
a.forEach(function(x) {
    a = [x,x,...a];
});
a = a.join(',');
fs.writeFileSync('out.json', a);
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const util = require('util');
fs
  .readFileSync('/dev/foo.js').toString()
  .indexOf('var n = 0;')
  .should.be.above(0);
console.warn("'fs' module not yet supported on the fly during compilation", JSON.stringify('fs'));

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

fs.writeFile('./js_hermes_sample.js', '', () => {})
```

**Hermes build options**
```
 

HermesConfig.enableExperimentalFeatures(true);


 

 
 
 
 
```

* [GitHub](https: 
* [Changelog](https: 
* [Getting Started](https: 
* [Tutorials](https: 
* [Release Notes](https: 

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const {HermesRuntime} = require("hermes-engine-rn");
const {HermesRuntime} = require("hermes-engine-rn");

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const path = require('path');
fs.write(1, 'Test Hermes', (error) => {
  console.log(error);
  console.log(error.stack);
});

 
Test Hermes: Error: Hermes's stack is not yet implemented for async functions and for Intl API. Use the optional argument withLegacyReactMode=true to emulate old RN behavior.

    at $r_error (native)
    at $r_throw (native)
*/

[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const hermes = require('hermes-engine');
const path = require('path');

const program = `
  export const {readFile, writeFile, stat} = {
    readFile(a: string, b?: {}) {
        return Promise.resolve();
    },
    writeFile(a: string, b: string) {
        return Promise.resolve();
    },
    stat(a: string, b?: {}) {
        return Promise.resolve();
    },
  };

  export const {arrayFromFloat64Array, arrayFromInt32Array, arrayFromUint32Array, arrayFromFloat32Array, arrayFromUint8Array} = {
    arrayFromFloat64Array(a: Float64Array) {
      return Promise.resolve();
    },
    arrayFromInt32Array(a: Int32Array) {
      return Promise.resolve();
    },
    arrayFromUint32Array(a: Uint32Array) {
      return Promise.resolve();
    },
    arrayFromFloat32Array(a: Float32Array) {
      return Promise.resolve();
    },
    arrayFromUint8Array(a: Uint8Array) {
      return Promise.resolve();
    },
  };

  export function arrayBufferToView(a: ArrayBuffer) {
    return Promise.resolve();
  }

  export function viewToArrayBuffer(a: Uint8Array) {
    return Promise.resolve();
  }

  export function readInt32(a: string) {
    return Promise.resolve(a);
  }

  export function writeInt32(a: number) {
    return Promise.resolve();
  }

  export function copyWithin() {
      return Promise.resolve();
  }

  export const {set, get, defineProperty, keys, entries, values, fromEntries} = {
    set() {
      return Promise.resolve();
    },
    get() {
      return Promise.resolve();
    },
    defineProperty() {
      return Promise.resolve();
    },
    keys() {
      return Promise.resolve();
    },
    entries() {
      return Promise.resolve();
    },
    values() {
      return Promise.resolve();
    },
    fromEntries() {
      return Promise.resolve();
    },
  };

  export const {getOwnPropertyDescriptor} = {
    getOwnPropertyDescriptor() {
      return Promise.resolve();
    },
  };

  export const {setPrototypeOf, getPrototypeOf} = {
    setPrototypeOf() {
      return Promise.resolve();
    },
    getPrototypeOf() {
      return Promise.resolve();
    },
  };
  `;

const hermesEngine = await hermes.setup({
  mode :'react',
  projectRoot : __dirname
});

if(!fs.existsSync(path.resolve('myBundle.js')))
{
  let code = program.trim();
  const compiled = await hermesEngine.compile(code);
  
  console.log(`\n${compiled.code}\n`);
  fs.writeFileSync(path.resolve('myBundle.js'), code);
}

const bytecodeBlob = new hermes.Blob(require(path.
[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const {Promise} = require('es6-promise');
console.log(Promise);
const prom1 = Promise.resolve('yes').then(() => {
  console.log(new Date().toString());
});
prom1.then((value) => {
  console.log('hi!');
  console.log(new Date().toString());
});
console.log('hello');
console.log(new Date().toString());
console.log(fs.readFileSync('README.md', {encoding: 'utf8'}));
console.log(new Date().toString());
console.log(prom1);
console.log(new Date().toString());

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const runtimePath = 'bundle-runtime';
if (fs.existsSync(runtimePath)) {
	 
  const HermesRuntime = require(runtimePath);
  const vm = new HermesRuntime.HermesVM();
  const func = new vm.HermesFunc(
"function greet(greeting, name?) {
    if (name) {
        return `Hello ${greeting} ${name} by ${this}.`;
    }
    return `Hello ${greeting}.`;
}",
  );
  fs.unlinkSync(runtimePath);
  const value = func.evaluate("document.body", "Hello World");
  console.log(`evaluated =\n${value}`);
}

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const path = require('path');
const readline = require('readline');
const WebSocket = require('ws');

const rl = readline.createInterface({
    input: fs.createReadStream(path.join(process.cwd(), 'examples/app.js')),
});

let ws = new WebSocket('ws://localhost:8081/graphql', [{ path: 'ws' }]);

ws.onopen = () => {
    rl.on('line', async word => {
        if (word === 'close') {
            ws.close();
            rl.close();
            process.exit();
        }
        await ws.send(word);
    });
};

rl.on('close', () => {
    rl.close();
});

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const fetch = require('node-fetch');
const parse = require('esprima').parse;
const transform = require('./HermesTransform');
 
const a = '1'.match(/(?<!\d)(\d+?)/)[1];  
const b = eval('1');  
const c = fetch('https://github.com', { method: 'POST' }).then(r => r.text());  
console.log(transform(parse(`(function a() { console.log(${a}); })();`)));
console.log(transform(parse(`a(1, 2, 3); a = b; console.log(a); a(b); c['']; try { c; } catch (e) { e; } 100 + 200; [1,2,3].forEach(function(e) { e; }); const a = Symbol.create('a'); const b = null; console.log(a.description); try { new Promise(() => {}); } catch (e) { e; } }`)));
console.log(transform(parse(`var a = BigInt('${a}'); const b = BigInt('${a}');console.log(a-b,a.toString(),b.toString());`)));
console.log(transform(parse(`let a;const b = BigInt('${a}');console.log(a-b,a.toString(),b.toString());`)));
console.log(transform(parse(`a = BigInt('${a}'); const b = BigInt('${a}');if(a<b) console.log('a is smaller',a,b);console.log(a-b,a.toString(),b.toString());`)));
 

[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const Promise = require('promise');

 
const filename = 'async.js';
let data ='return function() {\n' +
'    return new Promise((resolve) => {\n' +
'        setTimeout(resolve, 1000);\n' +
'    });\n' +
'}()';
fs.writeFileSync(filename, data);

let result = eval(data, { async: false }); 
console.log('result ='+ JSON.stringify(result));
let stats = fs.statSync(filename);
console.log(stats.ctime);

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const RN = require('react-native');

RN.render();

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

print(fs);  
print( fs.readFileSync('foo.js' );  
```


[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

function hello() {
  return 9;
}
fs.read(`${hello}?${1}`, 'utf8', 'base64');

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

(async function(arg) {
  console.log('arg', arg);
  if (!(await fs.read("/etc/passwd"))) {
    console.log('File exists');
  } else {
    console.log("The file does not exist");
  }
})("someValue")
```

More examples and test cases are coming soon.

See also [Wiki](https: 
```
npx hermes -h
npx hermes -h -v
npx hermes -x. -x./node_modules/ -x./package-lock.json
npx hermes -p./node_modules -p./package-lock.json
```

# License

Hermes is released under [MIT](LICENSE).

[VERBOSE] ========== sample =========
[VERBOSE] // Hermes is targeting ECMAScript 2015 (ES6) with some exceptions. It currently supports all ES6 JS library functions, ES6 Array and String searching functions, Set/Map, WeakSet/WeakMap, Array spread, Arrow functions, BigInt, Destructuring assignment, ES6 Promise, for..of loops, Generators, Intl APIs, Iteration, Object rest/spread, Optional chaining and nullish coalescing, Reflection, Shorthand property and computed property on object literals, Symbols, Template string literals, and TypedArrays.

Work is in progress for Async function, ES modules, Intl API glue, Symbol.prototype.description, and WeakRef. Planned features include block scoped variables, classes and method definitions, expanded Intl functionality, RegExp match indices and named capture groups.

However, Hermes excludes support for local mode eval(), features added to ECMAScript after ES6 not listed under "Supported", Realms, Symbol.species and its interactions with JS library functions, Symbol.unscopables, use of constructor property when creating new Arrays in Array.prototype methods, and with statements. 

There are also some incompatibilities, such as arguments changes in non-strict mode not syncing with named parameters, Function.prototype.toString not showing source because Hermes executes from bytecode, and Promise being implemented by pre-compiling the JS polyfill from RN as the internal bytecode. Users can opt-out of Hermes' Promise by passing -Xes6-promise=0 in CLI or setting withES6Promise(false) in the runtime configs.
/* Please create a very short program which uses Javascript and Hermes features in a complex way */
const fs = require('fs');
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const util = require('util');
function readFile(filename) {
  return new Promise((resolve) => {
     
    setTimeout(function() {
      resolve(fs.readFileSync(filename))
    }, 1000)
  })
}
const promise = readFile('filename');
function print(x) {
  console.log(x);
}[Symbol.asyncIterator]();
const anotherPromise = [promise, 0];
console.log(anotherPromise == [anotherPromise]);
const [data] = anotherPromise[Symbol.asyncIterator]:()=>anotherPromise;
try {
  await anotherPromise;
  console.log({error: 'Not support'});
} catch (e) {
  console.log({error: e});
}

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');



 

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');


function createFile() {
  return new Promise((resolve, reject) => {
    const content = 'Hello';
    let file = fs.createWriteStream('file.txt');
    file.on('finish', (e) => {
      resolve();
    });
    file.end(content, () => {
      reject();
    });
  });
}

Promise.resolve(createFile())
.then(function () {
    console.log('Hello from main thread');
  })
.catch(function (error) {
    console.warn('Caught exception from child thread');
    console.warn(String(error));
    process.exit(1);
  });

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const path = require('path');
const { spawn } = require('child_process');

const runHermes = (code, config = {
  entryFile,
  binaryFile,
  args,
  binaryPath,
  stdout,
  stderr,
  shell,
  cwd
}) => {
  const argsOptions = Object.entries(config.args || {}).map(([key, val]) => `-X${key}="${val}"`).join(' ');
  return new Promise((resolve, reject) => {
    const child = spawn(`${binaryPath}${shell? shell : ''}`, [binaryFile, `${debug? '-O' : ''}${binaryFile}${debug? '-o' : ''}${code}`, argsOptions, debug && '-d' || ''], {
      cwd,
      shell
    });

    child.stderr.on('data', data => {
      console.error(`[Hermes] ${data}`);
    });

    child.on('close', code => {
      if (code) {
        reject(new Error(`[Hermes] Unexpected exit code: ${code}`));
      }
      resolve(stdout? Buffer.from(stdout) : undefined);
    });
  });
};

[VERBOSE] ========== sample =========
[VERBOSE] ========== sample =========
[VERBOSE] const fs = require('fs');

const vm = require('vm');
const es6 = require('es6-module');
es6.set(vm.Script);
 

const a = new es6.Module();
a.importFunction('jsFunction',function(func){});
console.log('a.jsFunction()',a.jsFunction());
 

const a = new es6.Module();
a.importFunction('jsFunction',{name:'test',source:function(){},options:{},imports:{},functionName:{}});
console.log('a.jsFunction()',a.jsFunction());
 

const a = new es6.Module();
a.importFunction('jsFunction',{name:'test',options:{},imports:{test:function(){}}});
 

const a = new es6.Module();
const exp = require('./file.js');
exp.a = 1;
a.exportFunction('a',a.jsGlobal.a);
console.log('a.a',a.jsGlobal.a);
 
 

const a = new es6.Module();
a.importFunction('foo',{name:'test',source:function(){},options:{},imports:{},functionName:{}});
a.exportFunction('bar',a.jsGlobal.foo);
 

const a = new es6.Module();
a.importFunction('jsFunction',{name:'test',source:function(){},options:{},imports:{},functionName:{}});
const ret = a.jsFunction("Hello world!");
console.log('ret',ret);
 

var a = new es6.Module();
a.importString('abc', 'Hello World');
console.log('a.abc',a.jsGlobal.abc);
a.set('abc', 'a');
console.log('a.abc',a.jsGlobal.abc);

[VERBOSE] ========== sample =========
